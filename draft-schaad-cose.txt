



Network Working Group                                          J. Schaad
Internet-Draft                                            August Cellars
Intended status: Informational                         December 10, 2014
Expires: June 13, 2015


                      CBOR Encoded Message Syntax
                        draft-schaad-cose-latest

Abstract

   Make JOSE work with CBOR - but don't care about crypto compatability

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on June 13, 2015.

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.







Schaad                    Expires June 13, 2015                 [Page 1]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .  14
     1.1.  Design changes from JOSE  . . . . . . . . . . . . . . . .   3
     1.2.  Requirements Terminology  . . . . . . . . . . . . . . . .   3
     1.3.  CBOR Grammar  . . . . . . . . . . . . . . . . . . . . . .   3
   2.  The COSE_MSG structure  . . . . . . . . . . . . . . . . . . .   3
   3.  Key Format  . . . . . . . . . . . . . . . . . . . . . . . . .   4
   4.  Signing Structure . . . . . . . . . . . . . . . . . . . . . .   4
   5.  Encryption object . . . . . . . . . . . . . . . . . . . . . .   4
     5.1.  Header Parameters . . . . . . . . . . . . . . . . . . . .   6
     5.2.  Key Management Methods  . . . . . . . . . . . . . . . . .   7
       5.2.1.  Direct Encryption . . . . . . . . . . . . . . . . . .   7
       5.2.2.  Key Wrapping  . . . . . . . . . . . . . . . . . . . .   8
       5.2.3.  Key Encryption  . . . . . . . . . . . . . . . . . . .   8
       5.2.4.  Direct Key Agreement  . . . . . . . . . . . . . . . .   8
       5.2.5.  Key Agreement with Key Wrapping . . . . . . . . . . .   9
     5.3.  Encryption Algorithm for AEAD algorithms  . . . . . . . .   9
     5.4.  Encryption algorithm for AE algorithms  . . . . . . . . .  10
   6.  MAC objects . . . . . . . . . . . . . . . . . . . . . . . . .  10
   7.  Key Structure . . . . . . . . . . . . . . . . . . . . . . . .  10
   8.  Informational References  . . . . . . . . . . . . . . . . . .  11
   Appendix A.  AEAD and AE algorithms . . . . . . . . . . . . . . .  12
   Appendix B.  Examples . . . . . . . . . . . . . . . . . . . . . .  13
     B.1.  Direct Encryption . . . . . . . . . . . . . . . . . . . .  13
     B.2.  Wrapped Encryption  . . . . . . . . . . . . . . . . . . .  13
     B.3.  Direct ECDH . . . . . . . . . . . . . . . . . . . . . . .  13
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  14

1.  Introduction

   The JOSE working group produced a set of documents that defined how
   to perform encryption, signatures and message authentication (MAC)
   operations for JSON documents and then to encode the results using
   the JSON format [RFC7159].  This document does the same work for use
   with the CBOR [RFC7049] document format.  While there is a strong
   attempt to keep the flavor of the original JOSE documents, two
   considerations are taking into account:

      CBOR has capabilities that are not present in JSON and should be
      used.  One example of this is the fact that CBOR has a method of
      encoding binary directly without first converting it into a base64
      encoded sting.

      The authors did not always agree with some of the decisions made
      by the JOSE working group.  Many of these decisions have been re-
      examined, and where it seems to the authors to be superior,
      replaced.



Schaad                    Expires June 13, 2015                 [Page 2]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


1.1.  Design changes from JOSE

   o  We switched from using a map to using an array at the message
      level.  While this change means that it is no longer possible to
      add new information in the form of new fields to the message
      object, this ability is still there as this data can be added to
      the protected and unprotected maps.

1.2.  Requirements Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

   When the words appear in lower case, their natural language meaning
   is used.

1.3.  CBOR Grammar

   There currently is no standard CBOR grammar available for use by
   specifications.  In this document, we use a modified version of the
   CBOR data definition language (CDDL) defined in
   [I-D.greevenbosch-appsawg-cbor-cddl].  The differences between the
   defined grammar and the one we used are mostly self explanatory.  The
   biggest difference being the addition of the choice operator '|'.

2.  The COSE_MSG structure

   The COSE_MSG structure is a top level CBOR object which corresponds
   to the DataContent type in [CMS].  This structure allows for a top
   level message to be sent which could be any of the different security
   services, where the security service is identified.  The presence of
   this structure does not preclude a protocol to use one of the
   individual structures as a stand alone component.

   *COSE_MSG {
     msg_type : uint;
     ?sign_msg: COSE-Sign;         # present if msg_type = 0
     ?encrypt_msg: COSE-Encrypt;   # present if msg_type = 1
     ?mac_msg: COSE-MAC;           # present if msg_type = 2
   }

   This structure is encoded as an array by CBOR.  Descriptions of the
   fields:

      msg_type indicates which of the security structures is in this
      block.




Schaad                    Expires June 13, 2015                 [Page 3]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


3.  Key Format

4.  Signing Structure

   Describe an overview of things

   COSE-Sign : {
       payload : bstr;
       signatures: COSE-signature* | COSE-signature;
   }

   This structure is encoded as an array.  Field descriptions:

      payload contains the serialized content to be signed.

      signatures is either a single signature or an array of signature
      values.  [CREF1]

   COSE-signature :  {
       protected : bstr | null;
       unprotected : map(tstr);
       signature : bstr;
   }

   Field descriptions:

      protected is optional and contains additional information to be
      authenticated by the signature.  The field generally holds data
      about the signture operation or inner content.

      header is optional and contains additional information for
      evaluation of the signature.

   How to compute a signature:

      Concatenate the "protected" field and the "payload" field into a
      single octet string.  If the "protected" field is absent, use a
      zero length bstr object for it.

      Hash the resulting string

      Sign the hash

5.  Encryption object

   In this section we describe the structure and methods to be used when
   doing an encryption in COSE.  In COSE, we use the same techniques and
   structures for encrypting both the plain text and the keys used to



Schaad                    Expires June 13, 2015                 [Page 4]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   protect the text.  This is different from the approach used by both
   [CMS] and [I-D.ietf-jose-json-web-encryption] where different
   structures are used both for the plain text and for the different key
   management techniques.

   One of the by products of using the same technique for encrypting and
   encoding bot the content and the keys using the various key managment
   techniques, is a requirement that all of the key management
   techniques use an Authenticated Encryption (AE) algorithm.  When
   encrypting the plain text, it is normal to use an Authenticated
   Encryption with Additional Data (AEAD) algorithm.  For key
   management, either AE or AEAD algorithms can be used.  See Appendix A
   for more details about the different types of algorithms.

   The structure has two maps where data about the content can be
   placed.  The data placed here is also the data which is used to
   control how the decryption is to be done for this object.  When data
   is placed in these two structures, it is extremely poor practice to
   have data which is applicable to a different level.  For example, the
   unprotected field at the level of a key management decryption should
   not contain information either about how to interpret the plain text
   (i.e. content type) or how to convert the cipher text back to plain
   text (i.e. the kid for the recipient).

   COSE_encrypt {
     protected : bstr | null;   # Contains map(tstr)
     unprotected : map(tstr) | null;
     iv : bstr | null;
     aad : bstr | null;
     ciphertext : bstr | null;
     tag : bstr;
     recipients : COSE_encrypt_a* | null;
   }

   * COSE_encrypt_a : COSE_encrypt


   Description of the fields:

   protected  contains the information about the plain text or
      encryption process that is to be integrity protected.  The field
      is encoded in CBOR as a 'bstr' if present and the value 'null' if
      there is no data.  The contents of the protected field is a CBOR
      map of the protected data names and values.  The map is CBOR
      encoded before placing it into the bstr.






Schaad                    Expires June 13, 2015                 [Page 5]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   unprotected  contains infomration about the plain text that is not
      integrity protected.  If there are no field, then the value 'null'
      is used.

   iv contains the initialization vector (IV), or it's equivalent, if
      one is needed by the encryption algorithm.  If there is no IV,
      then the value 'null' is used.

   aad  contains additional authenticated data (aad) supplied by the
      application.  This field contains information about the plain text
      data that is authenticated, but not encrypted.  If the application
      does not provide this data, the value 'null' is used.

   cipherText  contains the encrypted plain text.  If the cipherText is
      to be transported independently of the control information about
      the encryption process (i.e. detached content) then the value
      'null' is encoded here.

   tag  [CREF2]

   recipients  contains the recipient information.  The field is an
      array of elements, one for each recipient.  If there is no
      recipient information, the value 'null' is used.  [CREF3]

5.1.  Header Parameters

   The header parameters discussed here are taken from
   [I-D.ietf-jose-json-web-encryption].  For the most part they are
   interpreted the same here as for JOSE.

   alg  contains the algorithm identifier used to encrypt the plain
      text.

   epk  contains an ephemeral key for key agreement management
      algorithms.

   zip  contains a compression algorithm identifier if the plain text
      was compressed prior to being encrypted.

   jku  contains a URL pointing to a JWK Set (defined in
      [I-D.ietf-jose-json-web-key]).  [CREF4]

   cwk  contains the public key fields for the key used to encrypt the
      object.

   kid  contains a value which can be used to select a key from one or
      more keys the application has access to.




Schaad                    Expires June 13, 2015                 [Page 6]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   cty  contains a string which identifies the content of the plain
      text.

   There are a number of header fields defined in
   [I-D.ietf-jose-json-web-encryption] which are not used.  These
   include PUT THE LIST OF UNUSED ITEMS HERE.  Includes 'enc'?

5.2.  Key Management Methods

   There are a number of different key management methods that can be
   used in the COSE encryption system.  In this section we will discuss
   each of the key management methods and what fields need to be
   specified to deal with each of them.

   The names of the key management methods used here are the same as are
   defined in [I-D.ietf-jose-json-web-key].  Other specifications use
   different terms for the key management methods or do not support some
   of the key management methods.

5.2.1.  Direct Encryption

   In direct encryption mode, a shared secret between the sender and the
   recipient is used as the CEK.  For direct encryption mode, no
   recipient structure is built.  All of the information about the key
   is placed in either the protected or unprotected fields at the
   content level.  When direct encryption mode is used, it MUST be the
   only mode used on the message.  It is a massive security leak to have
   both direct encryption and a different key management mode on the
   same message.

   For JOSE, direct encryption key management is the only key management
   method allowed for doing MAC-ed messages.  In COSE, all of the key
   management methods can be used for MAC-ed messages.

   The COSE_encrypt structure for the recipient is organized as follows:

   o  The 'protected', 'iv', 'aad', 'ciphertext' and 'recipients' fields
      MUST be null.

   o  The plain text to be encrypted is the key from next layer down
      (usually the content layer).

   o  At a minimum, the 'unprotected' field SHOULD contain the 'alg'
      parameter as well as a parameter identifying the shared secret.







Schaad                    Expires June 13, 2015                 [Page 7]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


5.2.2.  Key Wrapping

   In key wrapping mode, the CEK is randomly generated and that key is
   then encrypted by a shared secret between the sender and the
   recipient.  All of the currently defined key wrapping algorithms for
   JOSE (and thus for COSE) are AE algorithms.  Key wrapping mode is
   considered to be superior to direct encryption if the system has any
   capability for doing random key generation.  This is because the
   shared key is used to wrap random data rather than data has some
   degree of organization and may in fact be repeating the same content.

   The COSE_encrypt structure for the recipient is organized as follows:

   o  The 'protected', 'aad', and 'recipients' fields MUST be null.

   o  The plain text to be encrypted is the key from next layer down
      (usually the content layer).

   o  At a minimum, the 'unprotected' field SHOULD contain the 'alg'
      parameter as well as a parameter identifying the shared secret.

   o  Use of the 'iv' field will depend on the key wrap algorithm.

5.2.3.  Key Encryption

   Key Encryption mode is also called key transport mode in some
   standards.  Key Encryption mode differs from Key Wrap mode in that it
   uses an asymmetric encryption algorithm rather than a symmetric
   encryption algorithm to protect the key.  The only current Key
   Encryption mode algorithm supported is RSAES-OAEP.

   The COSE_encrypt structure for the recipient is organized as follows:

   o  The 'protected', 'aad', 'iv', and 'tag' fields all use the 'null'
      value.

   o  The plain text to be encrypted is the key from next layer down
      (usually the content layer).

   o  At a minimum, the 'unprotected' field SHOULD contain the 'alg'
      parameter as well as a parameter identifying the asymmetric key.

5.2.4.  Direct Key Agreement

   Direct Key Agreement derives the CEK from the shared secret computed
   by the key agreement operation.  For Direct Key Agreement, no
   recipient structure is built.  All of the information about the key




Schaad                    Expires June 13, 2015                 [Page 8]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   and key agreement process is placed in either the 'protected' or
   'unprotected' fields at the content level.

   When direct key agreement mode is used, it MUST be the only mode used
   on the message.  It is a security leak to have both direct key
   agreement and a different key management mode on the same message.

   The COSE_encrypt structure for the recipient is organized as follows:

   o  The 'protected', 'aad', 'iv', and 'tag' fields all use the 'null'
      value.

   o  At a minimum, the 'unprotected' field SHOULD contain the 'alg'
      parameter as well as a parameter identifying the asymmetric key.

   o  The 'unprotected' field MUST contain the 'epk' parameter.

5.2.5.  Key Agreement with Key Wrapping

   Key Agreement with Key Wrapping uses a randomly generated CEK.  The
   CEK is then encrypted using a Key Wrapping algorithm and a key
   derived from the shared secret computed by the key agreement
   algorithm.

   The COSE_encrypt structure for the recipient is organized as follows:

   o  The 'protected', 'aad', 'iv', and 'tag' fields all use the 'null'
      value.

   o  The plain text to be encrypted is the key from next layer down
      (usually the content layer).

   o  At a minimum, the 'unprotected' field SHOULD contain the 'alg'
      parameter, a parameter identifying the recipient asymmetric key,
      and a parameter with the sender's asymmetric public key.

5.3.  Encryption Algorithm for AEAD algorithms

   Nice short encryption algorithm.

   1.  Construct the octet string to be placed in the protected field:
       CBOR encode the protected data map, place it the protected field.

   2.  Construct the octet string to be used as the AAD value for the
       AEAD algorithm: Concatenate the values in the protected and aad
       fields after applying the CBOR bstr encoding to them.  [CREF5]





Schaad                    Expires June 13, 2015                 [Page 9]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   3.  Encrypt the plain text and place it in the ciphertext field.  The
       AAD value is passed in as part of the encryption process.

   4.  For recipient of the message, recursively perform the encryption
       algorithm for that recipient using the encryption key as the
       plain text.

5.4.  Encryption algorithm for AE algorithms

   1.  Verify that the protected field is empty.

   2.  Verify that the aad field is empty.

   3.  Encrypt the plain text and place in the ciphertext field.

6.  MAC objects

   add description

   COSE-mac :  {
      payload : bstr;
      protected : bstr | null;
      unprotected" : map(tstr) | null;
      tag : bstr;
      recipients : COSE_encrypt_a* | null;
   }

7.  Key Structure

   For COSE we use the same set of fields that were defined in
   [I-D.ietf-jose-json-web-key].

   COSE_key : map (tstr)

   The same fields defined in [I-D.ietf-jose-json-web-key] are used here
   with the following changes in rules:

      Any item which is base64 encoded in JWK, is bstr encoded for COSE.

      Any item which is integer encoded in JWK, is int encoded for COSE.

      Any item which is string (but not base64) encoded in JWK, is tstr
      encoded for COSE.

      Exceptions to this are the following fields:

      kid  is always bstr encoded rather than tstr encoded.  This change
         in encoded is due to the fact that frequently, values such as a



Schaad                    Expires June 13, 2015                [Page 10]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


         hash of the public key is used for a kid value.  Since the
         field is defined as not having a specific structure, making it
         binary rather than textual makes sense.

8.  Informational References

   [AES-GCM]  Dworkin, M., "NIST Special Publication 800-38D:
              Recommendation for Block Cipher Modes of Operation:
              Galois/Counter Mode (GCM) and GMAC.", .

   [CMS]      Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, September 2009.

   [I-D.greevenbosch-appsawg-cbor-cddl]
              Greevenbosch, B. and C. Vigano, "CBOR data definition
              language: a notational convention to express CBOR data
              structures.", draft-greevenbosch-appsawg-cbor-cddl-03
              (work in progress), September 2014.

   [I-D.ietf-jose-json-web-algorithms]
              Jones, M., "JSON Web Algorithms (JWA)", draft-ietf-jose-
              json-web-algorithms-37 (work in progress), November 2014.

   [I-D.ietf-jose-json-web-encryption]
              Jones, M. and J. Hildebrand, "JSON Web Encryption (JWE)",
              draft-ietf-jose-json-web-encryption-37 (work in progress),
              November 2014.

   [I-D.ietf-jose-json-web-key]
              Jones, M., "JSON Web Key (JWK)", draft-ietf-jose-json-web-
              key-37 (work in progress), November 2014.

   [I-D.ietf-jose-json-web-signature]
              Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", draft-ietf-jose-json-web-signature-37
              (work in progress), November 2014.

   [I-D.mcgrew-aead-aes-cbc-hmac-sha2]
              McGrew, D., Foley, J., and K. Paterson, "Authenticated
              Encryption with AES-CBC and HMAC-SHA", draft-mcgrew-aead-
              aes-cbc-hmac-sha2-05 (work in progress), July 2014.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC3394]  Schaad, J. and R. Housley, "Advanced Encryption Standard
              (AES) Key Wrap Algorithm", RFC 3394, September 2002.




Schaad                    Expires June 13, 2015                [Page 11]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   [RFC3447]  Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications
              Version 2.1", RFC 3447, February 2003.

   [RFC3610]  Whiting, D., Housley, R., and N. Ferguson, "Counter with
              CBC-MAC (CCM)", RFC 3610, September 2003.

   [RFC7049]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", RFC 7049, October 2013.

   [RFC7159]  Bray, T., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, March 2014.

Appendix A.  AEAD and AE algorithms

   The set of encryption algorithms that can be used with this
   specification is restricted to authenticated encryption (AE) and
   authenticated encryption with additional data (AEAD) algorithms.
   This means that there is a strong check that the data decrypted by
   the recipient is the same as what was encrypted by the sender.
   Encryption modes such as counter have no check on this at all.  The
   CBC encryption mode had a weak check that the data is correct, given
   a random key and random data, the CBC padding check will pass one out
   of 256 times.  There have been several times that a normal encryption
   mode has been combined with an integrity check to provide a content
   encryption mode that does provide the necessary authentication.  AES-
   GCM [AES-GCM], AES-CCM [RFC3610], AES-CBC-HMAC
   [I-D.mcgrew-aead-aes-cbc-hmac-sha2] are examples of these composite
   modes.

   PKCS v1.5 RSA key transport does not qualify as an AE algorithm.
   There are only three bytes in the encoding that can be checked as
   having decrypted correctly, the rest of the content can only be
   probabilistically checked as having decrypted correctly.  For this
   reason, PKCS v1.5 RSA key transport MUST NOT be used with this
   specification.  RSA-OAEP was designed to have the necessary checks
   that that content correctly decrypted and does qualify as an AE
   algorithm.

   When dealing with authenticated encryption algorithms, there is
   always some type of value that needs to be checked to see if the
   authentication level has passed.  This authentication value may be:

   o  A separately generated tag computed by both the encrypter and
      decrypter and then compared by the decryptor.  This tag value may
      be either placed at the end of the cipher text (the decision we
      made) or kept separately (the decision made by the JOSE working




Schaad                    Expires June 13, 2015                [Page 12]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


      group).  This is the approach followed by AES-GCM [AES-GCM] and
      AES-CCM [RFC3610].

   o  A fixed value which is part of the encoded plain text.  This is
      the approach followed by the AES key wrap algorithm [RFC3394].

   o  A computed value is included as part of the encoded plain text.
      The computed value is then checked by the decryptor using the same
      computation path.  This is the approach followed by RSAES-OAEP
      [RFC3447].

Appendix B.  Examples

B.1.  Direct Encryption

   This example has some features that are in questions but not yet in
   corperated in the document.

   To make it easier to read, this is a JSON dump rather than a binary
   dump

   Encoded in CBOR - 116 bytes, content is 14 bytes long

   [1, null, {"alg": "A128GCM"}, h'a5fc4e0092ba296a8c587e8d',
   h'aa9702fdf334be0efd90b3fcedf14903f1b778c4ebb80970990587f68fd4',
   null, {"alg": "dir", "kid": "77c7e2b8-6e13-45cf-8672-617b5b45243a"},
   null, null, null]

B.2.  Wrapped Encryption

   This example has some features that are in questions but not yet in
   corperated in the document.

   To make it easier to read, this is a JSON dump rather than a binary
   dump

   Encoded in CBOR - 144 bytes, content is 14 bytes long

 [1, null, {"alg": "A128GCM"}, h'9c48bb8097ac5267c8ac5207',
 h'e3dc16520f2f847530b53977d3d74d2c5fb4312711f91b4528c1cc951e5d',
 null, {"alg": "A128KW", "kid": "77c7e2b8-6e13-45cf-8672-617b5b45243a"},
 null, h'0e0e58acaf66fb57074a39614d970b09f93a8cf98fd826bc', null]

B.3.  Direct ECDH

   This example has some features that are in questions but not yet in
   corperated in the document.




Schaad                    Expires June 13, 2015                [Page 13]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   To make it easier to read, this is a JSON dump rather than a binary
   dump

   Encoded in CBOR - 216 bytes, content is 14 bytes long

[1, null, {"alg": "A128GCM"}, h'656d6a73ccf1b35fb99044e1',
h'd7b27b67a81b212ee513b148454fe2d571d51bb679239769f5d2299bb96b',
null, {"alg": "ECDH-ES", "epk": {"kty": "EC", "crv": "P-256",
"x": h'00b81ff1de0eeba27613027526d83b5f4cbffaca433488e3805e7a75c43bd1b966',
"y": h'00d142a334ac8790dc821abe9362434daeb00c1b8b076843e51a4a4717b30c54ce'},
"kid": "meriadoc.brandybuck@buckland.example"}, null, null, null]

Editorial Comments

[CREF1] JLS: Does it make sense to retain the flattened structure to
        save 1 or 2(?) bytes?

[CREF2] JLS: Is life easier if this goes away and becomes part of the
        cipher text?

[CREF3] JLS: Is there a reason to do a flatten on the recipient array?
        This is easier if we make the recipient structure a map as it
        becomes a difference between array vs map as the next item down.
        If we flatten for arrays, then it because a question of checking
        - "array, bstr" vs "array, array, bstr".  I don't know how hard
        this is to deal with.  We can also do the flattening in a
        different way as we can look at the length of the array if we
        just append the recipient vs doing an array of recipients.  I
        think this would work.  Implies the rule: recipients :
        COSE_encrypt | COSE_encrypt_a* | null;

[CREF4] JLS: Do we defined a cku as well?

[CREF5] JLS: Should we use the value null if the fields are not present
        rather than a zero length bstr.  (I.e. what is actually encoded
        in the final output.)

Author's Address

   Jim Schaad
   August Cellars

   Email: ietf@augustcellars.com








Schaad                    Expires June 13, 2015                [Page 14]
