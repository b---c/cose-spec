



Network Working Group                                          J. Schaad
Internet-Draft                                            August Cellars
Intended status: Informational                         December 15, 2014
Expires: June 18, 2015


                      CBOR Encoded Message Syntax
                        draft-schaad-cose-latest

Abstract

   Make JOSE work with CBOR - but don't care about crypto compatibility

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on June 18, 2015.

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.







Schaad                    Expires June 18, 2015                 [Page 1]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Design changes from JOSE  . . . . . . . . . . . . . . . .   3
     1.2.  Requirements Terminology  . . . . . . . . . . . . . . . .   3
     1.3.  CBOR Grammar  . . . . . . . . . . . . . . . . . . . . . .   3
   2.  The COSE_MSG structure  . . . . . . . . . . . . . . . . . . .   4
   3.  Signing Structure . . . . . . . . . . . . . . . . . . . . . .   4
   4.  Encryption object . . . . . . . . . . . . . . . . . . . . . .   6
     4.1.  Header Parameters . . . . . . . . . . . . . . . . . . . .   8
     4.2.  Key Management Methods  . . . . . . . . . . . . . . . . .   8
       4.2.1.  Direct Encryption . . . . . . . . . . . . . . . . . .   9
       4.2.2.  Key Wrapping  . . . . . . . . . . . . . . . . . . . .   9
       4.2.3.  Key Encryption  . . . . . . . . . . . . . . . . . . .  10
       4.2.4.  Direct Key Agreement  . . . . . . . . . . . . . . . .  10
       4.2.5.  Key Agreement with Key Wrapping . . . . . . . . . . .  11
     4.3.  Encryption Algorithm for AEAD algorithms  . . . . . . . .  11
     4.4.  Encryption algorithm for AE algorithms  . . . . . . . . .  11
   5.  MAC objects . . . . . . . . . . . . . . . . . . . . . . . . .  12
   6.  Key Structure . . . . . . . . . . . . . . . . . . . . . . . .  12
   7.  CBOR Encoder Restrictions . . . . . . . . . . . . . . . . . .  13
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  13
   9.  Security Considerations . . . . . . . . . . . . . . . . . . .  13
   10. Informative References  . . . . . . . . . . . . . . . . . . .  14
   Appendix A.  AEAD and AE algorithms . . . . . . . . . . . . . . .  15
   Appendix B.  Examples . . . . . . . . . . . . . . . . . . . . . .  16
     B.1.  Direct MAC  . . . . . . . . . . . . . . . . . . . . . . .  16
     B.2.  Wrapped MAC . . . . . . . . . . . . . . . . . . . . . . .  16
     B.3.  Direct ECDH . . . . . . . . . . . . . . . . . . . . . . .  16
     B.4.  Multiple Signers  . . . . . . . . . . . . . . . . . . . .  17
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  18

1.  Introduction

   The JOSE working group produced a set of documents that defined how
   to perform encryption, signatures and message authentication (MAC)
   operations for JSON documents and then to encode the results using
   the JSON format [RFC7159].  This document does the same work for use
   with the CBOR [RFC7049] document format.  While there is a strong
   attempt to keep the flavor of the original JOSE documents, two
   considerations are taking into account:

      CBOR has capabilities that are not present in JSON and should be
      used.  One example of this is the fact that CBOR has a method of
      encoding binary directly without first converting it into a base64
      encoded sting.





Schaad                    Expires June 18, 2015                 [Page 2]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


      The authors did not always agree with some of the decisions made
      by the JOSE working group.  Many of these decisions have been re-
      examined, and where it seems to the authors to be superior,
      replaced.

1.1.  Design changes from JOSE

   o  Define a top level message structure so that encrypted, signed and
      MAC-ed messages can easily identified and still have a consistent
      view.

   o  Switch from using a map to using an array at the message level.
      While this change means that it is no longer possible to add new
      information in the form of new fields to the message object, this
      ability is still there as this data can be added to the protected
      and unprotected maps.

   o  Signed messages separate the concept of protected and unprotected
      attributes that are for the content and the signature.

   o  Key management has been made to be more uniform.  All key
      management techniques are represented as a recipient rather than
      only have some of them be so.

   o  MAC messages are separated from signed messages.

   o  MAC messages have the ability to do key management on the MAC key.

   o  Use binary encodings for binary data rather than base64url
      encodings.

1.2.  Requirements Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

   When the words appear in lower case, their natural language meaning
   is used.

1.3.  CBOR Grammar

   There currently is no standard CBOR grammar available for use by
   specifications.  In this document, we use a modified version of the
   CBOR data definition language (CDDL) defined in
   [I-D.greevenbosch-appsawg-cbor-cddl].  The differences between the
   defined grammar and the one we used are mostly self explanatory.  The
   biggest difference being the addition of the choice operator '|'.



Schaad                    Expires June 18, 2015                 [Page 3]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   Additionally, note the use of the null value which is used to occupy
   a location in an array but to mark that the element is not present.

2.  The COSE_MSG structure

   The COSE_MSG structure is a top level CBOR object which corresponds
   to the DataContent type in [RFC5652].  This structure allows for a
   top level message to be sent which could be any of the different
   security services, where the security service is identified.  The
   presence of this structure does not preclude a protocol to use one of
   the individual structures as a stand alone component.

   *COSE_MSG {
     msg_type : uint;
     ?sign_msg: COSE-Sign;         # present if msg_type = 1
     ?encrypt_msg: COSE-Encrypt;   # present if msg_type = 2
     ?mac_msg: COSE-MAC;           # present if msg_type = 3
   }

   This structure is encoded as an array by CBOR.  Descriptions of the
   fields:

   msg_type  indicates which of the security structures is in this
      block.

3.  Signing Structure

   Describe an overview of things

   COSE_Sign : {
       protected : bstr | null;
       unprotected : map(tstr) | null;
       payload : bstr | null;
       signatures: COSE_signature_a* | COSE_signature;
   }

   This structure is encoded as an array.  Field descriptions:

   protected  contains attributes about the payload which are to be
      protected by the signature.  An example of such an attribute would
      be the content type ('cty') attribute.  The content is a CBOR map
      of attributes which is encoded to a byte stream.  This field MUST
      NOT contain attributes about the signature, even if those
      attributes are common across multiple signatures.  At least one of
      protected and unprotected MUST be present.

   unprotected  contains attributes about the payload which are not
      protected by the signature.  An example of such an attribute would



Schaad                    Expires June 18, 2015                 [Page 4]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


      be the content type ('cty') attribute.  This field MUST NOT
      contain attributes about a signature, even if the attributes are
      common across multiple signatures.  At least one of protected and
      unprotected MUST be present.

   payload  contains the serialized content to be signed.  If the
      payload is not present in the message, the application is required
      to supply the payload separately.  The payload is wrapped in a
      bstr to ensure that it is transported without changes, if the
      payload is transported separately it is the responsibility of the
      application to ensure that it will be transported without changes.

   signatures  is either a single signature or an array of signature
      values.  It is legal to use the array of signature values for a
      single signature.  Implementations MUST be able to parse both
      layouts.

   COSE_signature :  {
       protected : bstr | null;
       unprotected : map(tstr) | null;
       signature : bstr;
   }
   *COSE_signature_a : COSE_signature;

   Field descriptions:

   protected  is optional and contains additional information to be
      authenticated by the signature.  The field holds data about the
      signature operation.  The field MUST NOT hold attributes about the
      payload being signed.  The content is a CBOR map of attributes
      which is encoded to a byte stream.  At least one of protected and
      unprotected MUST be present.

   unprotected  contains attributes about the signature which are not
      protected by the signature.  This field MUST NOT contain
      attributes about the payload being signed.  At least one of
      protected and unprotected MUST be present.

   signature  contains the computed signature value.

   *Sig_structure : {
       body_protected : bstr | null;
       sign_protected : bstr | null;
       payload : bstr | null;
   }

   How to compute a signature:




Schaad                    Expires June 18, 2015                 [Page 5]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   1.  Create a Sig_structure object and populate it with the
       appropriate fields.

   2.  Create the value to be hashed by encode the Sig_structure to a
       byte string.

   3.  Sign the hash

   4.  Place the signature value into the appropriate signature field.

4.  Encryption object

   In this section we describe the structure and methods to be used when
   doing an encryption in COSE.  In COSE, we use the same techniques and
   structures for encrypting both the plain text and the keys used to
   protect the text.  This is different from the approach used by both
   [RFC5652] and [I-D.ietf-jose-json-web-encryption] where different
   structures are used both for the plain text and for the different key
   management techniques.

   One of the by products of using the same technique for encrypting and
   encoding both the content and the keys using the various key
   management techniques, is a requirement that all of the key
   management techniques use an Authenticated Encryption (AE) algorithm.
   When encrypting the plain text, it is normal to use an Authenticated
   Encryption with Additional Data (AEAD) algorithm.  For key
   management, either AE or AEAD algorithms can be used.  See Appendix A
   for more details about the different types of algorithms.

   The structure has two maps where data about the content can be
   placed.  The data placed here is also the data which is used to
   control how the decryption is to be done for this object.  When data
   is placed in these two structures, it is extremely poor practice to
   have data which is applicable to a different level.  For example, the
   unprotected field at the level of a key management decryption should
   not contain information either about how to interpret the plain text
   (i.e. content type) or how to convert the cipher text back to plain
   text (i.e. the kid for the recipient).













Schaad                    Expires June 18, 2015                 [Page 6]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   COSE_encrypt {
     protected : bstr | null;   # Contains map(tstr)
     unprotected : map(tstr) | null;
     iv : bstr | null;
     aad : bstr | null;
     ciphertext : bstr | null;
     tag : bstr;
     recipients : COSE_encrypt_a* | null;
   }
   * COSE_encrypt_a : COSE_encrypt

   Description of the fields:

   protected  contains the information about the plain text or
      encryption process that is to be integrity protected.  The field
      is encoded in CBOR as a 'bstr' if present and the value 'null' if
      there is no data.  The contents of the protected field is a CBOR
      map of the protected data names and values.  The map is CBOR
      encoded before placing it into the bstr.

   unprotected  contains information about the plain text that is not
      integrity protected.  If there are no field, then the value 'null'
      is used.

   iv contains the initialization vector (IV), or it's equivalent, if
      one is needed by the encryption algorithm.  If there is no IV,
      then the value 'null' is used.

   aad  contains additional authenticated data (aad) supplied by the
      application.  This field contains information about the plain text
      data that is authenticated, but not encrypted.  If the application
      does not provide this data, the value 'null' is used.

   cipherText  contains the encrypted plain text.  If the cipherText is
      to be transported independently of the control information about
      the encryption process (i.e. detached content) then the value
      'null' is encoded here.

   tag  [CREF1]

   recipients  contains the recipient information.  The field is an
      array of elements, one for each recipient.  If there is no
      recipient information, the value 'null' is used.  [CREF2]








Schaad                    Expires June 18, 2015                 [Page 7]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


4.1.  Header Parameters

   The header parameters discussed here are taken from
   [I-D.ietf-jose-json-web-encryption].  For the most part they are
   interpreted the same here as for JOSE.

   alg  contains the algorithm identifier used to encrypt the plain
      text.

   epk  contains an ephemeral key for key agreement management
      algorithms.  Note however, that it is a COSE encoded key and not a
      JOSE encoded key.

   zip  contains a compression algorithm identifier if the plain text
      was compressed prior to being encrypted.

   jku  contains a URL pointing to a JWK Set (defined in
      [I-D.ietf-jose-json-web-key]).  [CREF3]

   cwk  contains the public key fields for the key used to encrypt the
      object.

   kid  contains a value which can be used to select a key from one or
      more keys the application has access to.

   cty  contains a string which identifies the content of the plain
      text.

   There are a number of header fields defined in
   [I-D.ietf-jose-json-web-encryption] which are not used.  These
   include PUT THE LIST OF UNUSED ITEMS HERE.  Includes 'enc'?

4.2.  Key Management Methods

   There are a number of different key management methods that can be
   used in the COSE encryption system.  In this section we will discuss
   each of the key management methods and what fields need to be
   specified to deal with each of them.

   The names of the key management methods used here are the same as are
   defined in [I-D.ietf-jose-json-web-key].  Other specifications use
   different terms for the key management methods or do not support some
   of the key management methods.

   At the moment we do not have any key management methods that allow
   for the use of protected headers.  This may be changed in the future
   if, for example, the AES-GCM Key wrap method defined in [JWA] were
   extended to allow for authenticated data.  In that event the use of



Schaad                    Expires June 18, 2015                 [Page 8]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   the 'protected' field, which is current forbidden below, would be
   permitted.

4.2.1.  Direct Encryption

   In direct encryption mode, a shared secret between the sender and the
   recipient is used as the CEK.  For direct encryption mode, no
   recipient structure is built.  All of the information about the key
   is placed in either the protected or unprotected fields at the
   content level.  When direct encryption mode is used, it MUST be the
   only mode used on the message.  It is a massive security leak to have
   both direct encryption and a different key management mode on the
   same message.

   For JOSE, direct encryption key management is the only key management
   method allowed for doing MAC-ed messages.  In COSE, all of the key
   management methods can be used for MAC-ed messages.

   The COSE_encrypt structure for the recipient is organized as follows:

   o  The 'protected', 'iv', 'aad', 'ciphertext' and 'recipients' fields
      MUST be null.

   o  The plain text to be encrypted is the key from next layer down
      (usually the content layer).

   o  At a minimum, the 'unprotected' field SHOULD contain the 'alg'
      parameter as well as a parameter identifying the shared secret.

4.2.2.  Key Wrapping

   In key wrapping mode, the CEK is randomly generated and that key is
   then encrypted by a shared secret between the sender and the
   recipient.  All of the currently defined key wrapping algorithms for
   JOSE (and thus for COSE) are AE algorithms.  Key wrapping mode is
   considered to be superior to direct encryption if the system has any
   capability for doing random key generation.  This is because the
   shared key is used to wrap random data rather than data has some
   degree of organization and may in fact be repeating the same content.

   The COSE_encrypt structure for the recipient is organized as follows:

   o  The 'protected', 'aad', and 'recipients' fields MUST be null.

   o  The plain text to be encrypted is the key from next layer down
      (usually the content layer).





Schaad                    Expires June 18, 2015                 [Page 9]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   o  At a minimum, the 'unprotected' field SHOULD contain the 'alg'
      parameter as well as a parameter identifying the shared secret.

   o  Use of the 'iv' field will depend on the key wrap algorithm.

4.2.3.  Key Encryption

   Key Encryption mode is also called key transport mode in some
   standards.  Key Encryption mode differs from Key Wrap mode in that it
   uses an asymmetric encryption algorithm rather than a symmetric
   encryption algorithm to protect the key.  The only current Key
   Encryption mode algorithm supported is RSAES-OAEP.

   The COSE_encrypt structure for the recipient is organized as follows:

   o  The 'protected', 'aad', 'iv', and 'tag' fields all use the 'null'
      value.

   o  The plain text to be encrypted is the key from next layer down
      (usually the content layer).

   o  At a minimum, the 'unprotected' field SHOULD contain the 'alg'
      parameter as well as a parameter identifying the asymmetric key.

4.2.4.  Direct Key Agreement

   Direct Key Agreement derives the CEK from the shared secret computed
   by the key agreement operation.  For Direct Key Agreement, no
   recipient structure is built.  All of the information about the key
   and key agreement process is placed in either the 'protected' or
   'unprotected' fields at the content level.

   When direct key agreement mode is used, it MUST be the only mode used
   on the message.  It is a security leak to have both direct key
   agreement and a different key management mode on the same message.

   The COSE_encrypt structure for the recipient is organized as follows:

   o  The 'protected', 'aad', 'iv', and 'tag' fields all use the 'null'
      value.

   o  At a minimum, the 'unprotected' field SHOULD contain the 'alg'
      parameter as well as a parameter identifying the asymmetric key.

   o  The 'unprotected' field MUST contain the 'epk' parameter.






Schaad                    Expires June 18, 2015                [Page 10]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


4.2.5.  Key Agreement with Key Wrapping

   Key Agreement with Key Wrapping uses a randomly generated CEK.  The
   CEK is then encrypted using a Key Wrapping algorithm and a key
   derived from the shared secret computed by the key agreement
   algorithm.

   The COSE_encrypt structure for the recipient is organized as follows:

   o  The 'protected', 'aad', 'iv', and 'tag' fields all use the 'null'
      value.

   o  The plain text to be encrypted is the key from next layer down
      (usually the content layer).

   o  At a minimum, the 'unprotected' field SHOULD contain the 'alg'
      parameter, a parameter identifying the recipient asymmetric key,
      and a parameter with the sender's asymmetric public key.

4.3.  Encryption Algorithm for AEAD algorithms

   Nice short encryption algorithm.

   1.  Construct the octet string to be placed in the protected field:
       CBOR encode the protected data map, place it the protected field.

   2.  Construct the octet string to be used as the AAD value for the
       AEAD algorithm: Concatenate the values in the protected and aad
       fields after applying the CBOR bstr encoding to them.  [CREF4]

   3.  Encrypt the plain text and place it in the ciphertext field.  The
       AAD value is passed in as part of the encryption process.

   4.  For recipient of the message, recursively perform the encryption
       algorithm for that recipient using the encryption key as the
       plain text.

4.4.  Encryption algorithm for AE algorithms

   1.  Verify that the protected field is empty.

   2.  Verify that the aad field is empty.

   3.  Encrypt the plain text and place in the ciphertext field.







Schaad                    Expires June 18, 2015                [Page 11]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


5.  MAC objects

   add description

   COSE_mac :  {
      protected : bstr | null;
      unprotected" : map(tstr) | null;
      payload : bstr;
      tag : bstr;
      recipients : COSE_encrypt_a* | COSE_encrypt | null;
   }

6.  Key Structure

   There are only a few changes between JOSE and COSE for how keys are
   formatted.  As with JOSE, COSE uses a map to contain the elements of
   a key.  Those values, which in JOSE, are base64url encoded because
   they are binary values, are encoded as bstr values in COSE.

   For COSE we use the same set of fields that were defined in
   [I-D.ietf-jose-json-web-key].

   COSE_Key : map(tstr, *) {
       "kty" : tstr;
       ?"use" : tstr;
       ?"key_ops" : tstr*;
       ?"alg" : tstr;
       ?"kid" : tstr;
   }

   *COSE_KeySet : COSE_Key*;

   The element "kty" is a required element in a COSE_Key map.
   All other elements are optional and not all of the elements listed in
   [JWK] or [JWA] have been listed here even though they can all appear
   in a COSE_Key map.

   The "key_ops" element is prefered over the "use" element as the
   information provided that way is more finely detailed about the
   operations allowed.  It is strongly suggested that this element be
   present for all keys.

   The same fields defined in [I-D.ietf-jose-json-web-key] are used here
   with the following changes in rules:

      Any item which is base64 encoded in JWK, is bstr encoded for COSE.

      Any item which is integer encoded in JWK, is int encoded for COSE.



Schaad                    Expires June 18, 2015                [Page 12]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


      Any item which is string (but not base64) encoded in JWK, is tstr
      encoded for COSE.



      Exceptions to this are the following fields:

      kid  is always bstr encoded rather than tstr encoded.  This change
         in encoded is due to the fact that frequently, values such as a
         hash of the public key is used for a kid value.  Since the
         field is defined as not having a specific structure, making it
         binary rather than textual makes sense.

7.  CBOR Encoder Restrictions

   There as been an attempt to resrict the number of places where the
   document needs to impose restrictions on how the CBOR Encoder needs
   to work.  We have managed to narrow it down to the following
   restrictions:

      The restriction applies only the encoding the Sig_structure.

      The rules for Canonical CBOR (Section 3.9 of RFC 7049) MUST be
      used in these locations.  The main rule that needs to be enforced
      is that all lengths in these structures MUST be encoded such that
      they are encoded using definite lengths and the minimum length
      encoding is used.

8.  IANA Considerations

   There are IANA considerations to be filled in.

9.  Security Considerations

   There are security considertions:

   1.  Protect private keys

   2.  MAC messages with more than one recipient means one cannot figure
       out who sent the message

   3.  Use of direct key with other recipient structures hands the key
       to other recipients.

   4.  Use of direcct ECDH direct encryption is easy for people to leak
       information on if there are other recipients in the message.





Schaad                    Expires June 18, 2015                [Page 13]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


10.  Informative References

   [AES-GCM]  Dworkin, M., "NIST Special Publication 800-38D:
              Recommendation for Block Cipher Modes of Operation:
              Galois/Counter Mode (GCM) and GMAC.", December 2014.

   [I-D.greevenbosch-appsawg-cbor-cddl]
              Greevenbosch, B. and C. Vigano, "CBOR data definition
              language: a notational convention to express CBOR data
              structures.", draft-greevenbosch-appsawg-cbor-cddl-03
              (work in progress), September 2014.

   [I-D.ietf-jose-json-web-algorithms]
              Jones, M., "JSON Web Algorithms (JWA)", draft-ietf-jose-
              json-web-algorithms-38 (work in progress), December 2014.

   [I-D.ietf-jose-json-web-encryption]
              Jones, M. and J. Hildebrand, "JSON Web Encryption (JWE)",
              draft-ietf-jose-json-web-encryption-38 (work in progress),
              December 2014.

   [I-D.ietf-jose-json-web-key]
              Jones, M., "JSON Web Key (JWK)", draft-ietf-jose-json-web-
              key-38 (work in progress), December 2014.

   [I-D.ietf-jose-json-web-signature]
              Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", draft-ietf-jose-json-web-signature-38
              (work in progress), December 2014.

   [I-D.mcgrew-aead-aes-cbc-hmac-sha2]
              McGrew, D., Foley, J., and K. Paterson, "Authenticated
              Encryption with AES-CBC and HMAC-SHA", draft-mcgrew-aead-
              aes-cbc-hmac-sha2-05 (work in progress), July 2014.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC3394]  Schaad, J. and R. Housley, "Advanced Encryption Standard
              (AES) Key Wrap Algorithm", RFC 3394, September 2002.

   [RFC3447]  Jonsson, J. and B. Kaliski, "Public-Key Cryptography
              Standards (PKCS) #1: RSA Cryptography Specifications
              Version 2.1", RFC 3447, February 2003.

   [RFC3610]  Whiting, D., Housley, R., and N. Ferguson, "Counter with
              CBC-MAC (CCM)", RFC 3610, September 2003.




Schaad                    Expires June 18, 2015                [Page 14]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, September 2009.

   [RFC7049]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", RFC 7049, October 2013.

   [RFC7159]  Bray, T., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, March 2014.

Appendix A.  AEAD and AE algorithms

   The set of encryption algorithms that can be used with this
   specification is restricted to authenticated encryption (AE) and
   authenticated encryption with additional data (AEAD) algorithms.
   This means that there is a strong check that the data decrypted by
   the recipient is the same as what was encrypted by the sender.
   Encryption modes such as counter have no check on this at all.  The
   CBC encryption mode had a weak check that the data is correct, given
   a random key and random data, the CBC padding check will pass one out
   of 256 times.  There have been several times that a normal encryption
   mode has been combined with an integrity check to provide a content
   encryption mode that does provide the necessary authentication.  AES-
   GCM [AES-GCM], AES-CCM [RFC3610], AES-CBC-HMAC
   [I-D.mcgrew-aead-aes-cbc-hmac-sha2] are examples of these composite
   modes.

   PKCS v1.5 RSA key transport does not qualify as an AE algorithm.
   There are only three bytes in the encoding that can be checked as
   having decrypted correctly, the rest of the content can only be
   probabilistically checked as having decrypted correctly.  For this
   reason, PKCS v1.5 RSA key transport MUST NOT be used with this
   specification.  RSA-OAEP was designed to have the necessary checks
   that that content correctly decrypted and does qualify as an AE
   algorithm.

   When dealing with authenticated encryption algorithms, there is
   always some type of value that needs to be checked to see if the
   authentication level has passed.  This authentication value may be:

   o  A separately generated tag computed by both the encrypter and
      decrypter and then compared by the decryptor.  This tag value may
      be either placed at the end of the cipher text (the decision we
      made) or kept separately (the decision made by the JOSE working
      group).  This is the approach followed by AES-GCM [AES-GCM] and
      AES-CCM [RFC3610].

   o  A fixed value which is part of the encoded plain text.  This is
      the approach followed by the AES key wrap algorithm [RFC3394].



Schaad                    Expires June 18, 2015                [Page 15]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


   o  A computed value is included as part of the encoded plain text.
      The computed value is then checked by the decryptor using the same
      computation path.  This is the approach followed by RSAES-OAEP
      [RFC3447].

Appendix B.  Examples

B.1.  Direct MAC

   This example has some features that are in questions but not yet
   incorporated in the document.

   To make it easier to read, this uses CBOR's diagnostic notation
   rather than a binary dump.

   Encoded in CBOR - 118 bytes, content is 14 bytes long

   [2, null, {"alg": "HS256"}, h'436f6e74656e7420537472696e67',
   h'78956d858ee6c026ac630063627a4ce98d3003bc68e7c1e53b5b468331b69f93',
   null, {"alg": "dir", "kid": "018c0ae5-4d9b-471b-bfd6-eef314bc7037"},
   null, null, null]

B.2.  Wrapped MAC

   This example has some features that are in questions but not yet
   incorporated in the document.

   To make it easier to read, this uses CBOR's diagnostic notation
   rather than a binary dump.

   Encoded in CBOR - 162 bytes, content is 14 bytes long

[2, null, {"alg": "HS256"}, h'436f6e74656e7420537472696e67',
h'2ee486376b8b2a61fe526589ceb456e20919a68ebc0458431ef3e13ffe7bf698',
null, {"alg": "A128KW", "kid": "77c7e2b8-6e13-45cf-8672-617b5b45243a"},
null,
h'4f6e9e6a3e43b79561ef602a2a9e629a437e8df90a7ff361acbdb1076c955d0f25c660a67aee1bdf',
null]

B.3.  Direct ECDH

   This example has some features that are in questions but not yet
   incorporated in the document.

   To make it easier to read, this uses CBOR's diagnostic notation
   rather than a binary dump.

   Encoded in CBOR - 216 bytes, content is 14 bytes long



Schaad                    Expires June 18, 2015                [Page 16]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


[1, null, {"alg": "A128GCM"}, h'656d6a73ccf1b35fb99044e1',
h'd7b27b67a81b212ee513b148454fe2d571d51bb679239769f5d2299bb96b',
null, {"alg": "ECDH-ES", "epk": {"kty": "EC", "crv": "P-256",
"x": h'00b81ff1de0eeba27613027526d83b5f4cbffaca433488e3805e7a75c43bd1b966',
"y": h'00d142a334ac8790dc821abe9362434daeb00c1b8b076843e51a4a4717b30c54ce'},
"kid": "meriadoc.brandybuck@buckland.example"}, null, null, null]

B.4.  Multiple Signers

   This example has some features that are in questions but not yet
   cooperated in the document.

   To make it easier to read, this uses CBOR's diagnostic notation
   rather than a binary dump.

   Encoded in CBOR - 491 bytes, content is 14 bytes long

[0, null, null, h'436f6e74656e7420537472696e67', [
[null, {"kid": "bilbo.baggins@hobbiton.example", "alg": "PS256"},
h'5afe80ec9f208b4719a3bd688c803a3154b1ff25af86e054173ad6ddf71ba77a4a2b793beed077a4e1a8a69ac1277c457f636691cb4a7d3dc67b47ec84c067076b720236bae498bdb21deebbc0a0f525f9a24b336d51e2b3effd67df3e051405a3599aed83b8a8e94e4194dded2f661e5e6894825779b79b463bd4f477f33356cf8aecfa8a543344d2620145be8a72a712f985457040140176164c77cdae7cc480ae4357683cce79b97ddb10f390862a242aae1aa391cc730b1631f020874a8a6efc77b08f027323e2c4ae85eeb3e5dc715e0e2fa8aec63fb828d7a2c45e361e249117bd8b41e1e12388412d8ce3809c9a2172afda5ca7c5839896825da66a50'],
[null, {"kid": "bilbo.baggins@hobbiton.example", "alg": "ES512"},
h'00e9769c05afb2d93baf5a0c2cace1747b5091f50596831911c67ebf76f4220adb53698fe7831000d526887893d67de05ead1bbe378ce9e9731bda4cd37f53dcf8d40186c46d872795b566682c113cc9d5bf5a8c5321fd50a003237115decf0cb8b09e5c3cb50bc2203af45bebd51e6c4d0ec51170d5b9ac1b21a2017a50d7c15b6de8f9']]]

Editorial Comments

[CREF1] JLS: Is life easier if this goes away and becomes part of the
        cipher text?

[CREF2] JLS: Is there a reason to do a flatten on the recipient array?
        This is easier if we make the recipient structure a map as it
        becomes a difference between array vs map as the next item down.
        If we flatten for arrays, then it because a question of checking
        - "array, bstr" vs "array, array, bstr".  I don't know how hard
        this is to deal with.  We can also do the flattening in a
        different way as we can look at the length of the array if we
        just append the recipient vs doing an array of recipients.  I
        think this would work.  Implies the rule: recipients :
        COSE_encrypt | COSE_encrypt_a* | null;

[CREF3] JLS: Do we defined a cku as well?

[CREF4] JLS: Should we use the value null if the fields are not present
        rather than a zero length bstr.  (I.e. what is actually encoded
        in the final output.)







Schaad                    Expires June 18, 2015                [Page 17]

Internet-Draft         CBOR Encoded Message Syntax         December 2014


Author's Address

   Jim Schaad
   August Cellars

   Email: ietf@augustcellars.com













































Schaad                    Expires June 18, 2015                [Page 18]
